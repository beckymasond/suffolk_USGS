{
    "contents" : "\"\nAuthor: Joe Tuccillo\n\nDescription: Helper functions for data preparation, cluster analysis, \n  and diagnostics and visualization of results. \n\nFunctions: \n\n  toProp: Converts count variables to a proportion of the source\n    dataset total.\n\n  plotMap: Plots a thematic map of one or more cluster solutions. \n\n  compareMv: Computes the mean vector of variables of interest by\n    cluster groups. If specified, compares the mean vector of target\n    variables to the overall mean vector. \n\n  plotHeat: Plots average profile characteristics of variables of interest\n    by cluster groups in a 'heatmap' style raster plot. If specified, \n    compares multiple cluster solutions or domains of variables of interest.\n\n\n\"\n\nlibrary(rgeos)\nlibrary(maptools)\nlibrary(RColorBrewer)\nlibrary(cluster)\nlibrary(ggplot2)\nlibrary(reshape2)\nlibrary(fpc)\n\ntoprop<-function(inData){\n  \n  \"\n  Converts count variables to a proportion of the source\n  dataset total.\n\n  Arguments: \n\n    inData: data frame containing a geographic identifier ('GEOID')\n      and total population ('TOTAL') field.\n\n  Returns: data frame of input variables scaled as proportions of the \n    source dataset total. \n    \n  \"\n  \n  return(data.frame(GEOID=inData$GEOID,sapply(X=inData[,-c(1:2)],FUN=function(X){X/inData$TOTAL}))) \n  \n}\n\nplotMap<-function(inGeom,inClust,geomKey=\"GEOID\",clustKey=\"GEOID\",compare=FALSE,map.title=NULL,\n                  custom.colors=NULL,legend.key.extend=FALSE,plot.borders=T,plot.basemap=F,\n                  base.geom=NULL,hide.gridlines=F,return.map=F){\n  \n  \"\n  Plots a thematic map of one or more cluster solutions. \n  \n  Arguments:\n  \n    inGeom: a SpatialPolygons data frame consisting of cluster analysis aggregation units.  \n\n    geomKey: 'inGeom' geographic identifier for merge (default is 'GEOID'). \n\n    inClust: a data frame consisting of a geographic identifier and cluster membership \n      ('cluster') fields.\n\n    clustKey: 'inClust' geographic identifier for merge (default is 'GEOID'). \n\n    custom.colors: optional. A character vector of hex color codes for map categories. \n      Uses RColorBrewer 'Spectral' if none specified.\n\n    map.title: an optional title for map.\n\n    compare: optional. If TRUE, plots multiple maps using a 'series' field.\n\n    legend.key.extend: optional. If TRUE, increase the height of the legend key items. This is\n      useful when using extended legend labels.\n\n    plot.borders: optional. If TRUE (default), add aggregation unit boundaries to map.title\n  \n    plot.basemap: optional. If TRUE, add outlines or boundaries to map using another \n      SpatialPolygons object.\n\n    base.geom: optional. Basemap geometry, a SpatialPolygons object.\n    \n    hide.gridlines: optional. If TRUE, remove default ggplot background.\n\n    return.map: optional. if TRUE, returns the ggplot map object.\n  \n  Returns: \n  \n    The ggplot map object, when 'return.map=TRUE'. Default behavior is to return a\n    plot in the R graphics device.\n  \n  \"\n  \n  #Fortify inGeom\n  map_df<-fortify(inGeom,region=geomKey)\n  \n  #merge the data\n  map_df<-merge(inClust,map_df,by.x=clustKey,by.y=\"id\")\n  \n  ##Identify holes for subset in plot\n  #We need to convert from factor->character->factor to remove unecessary levels\n  holes<-as.factor((map_df[map_df$hole==TRUE,][[clustKey]]))\n  \n  #Assign boolean to blocks with holes \n  map_df$has.hole<-map_df[[clustKey]] %in% holes\n  \n  #Order the map dataframe \n  # map_df<-map_df[order(map_df$variable,map_df$GEOID,map_df$order),]\n  map_df<-map_df[order(map_df[[clustKey]],map_df$order),]\n  \n  #Make sure the \"value\" field is a factor\n  map_df$cluster<-as.factor(map_df$cluster)\n  \n  #Generate map \n  map.out<-ggplot(aes(long,lat,group=group),data=map_df) + \n    geom_polygon(data=subset(map_df,has.hole==TRUE),aes(fill=cluster))+\n    geom_polygon(data=subset(map_df,has.hole==FALSE),aes(fill=cluster))+\n    coord_equal()+\n    # geom_path(data=inGeom, colour = \"gray40\", size = .5,alpha=.2)+\n    theme(legend.title=element_blank())\n  \n  #Plot borders\n  if (plot.borders){\n    \n    map.out<-map.out+geom_path(data=inGeom, colour = \"gray40\", size = .5,alpha=.2)\n    \n  }\n  \n  if (plot.basemap){\n    \n    map.out<-map.out+geom_path(data=base.geom, colour = \"gray40\", size = .6)\n    \n  }\n  \n  #Hide gridlines (background)\n  if (hide.gridlines){\n    \n    map.out<-map.out+theme(panel.background = element_blank())\n    \n  }\n  \n  \n  #Color ramp\n  if (is.null(custom.colors)){ #Default to 'Spectral' ColorBrewer ramp \n    \n    map.out<-map.out+scale_fill_brewer(palette=\"Spectral\")\n    \n  }else{\n    \n    map.out<-map.out+scale_fill_manual(values = custom.colors)+scale_colour_identity()\n    \n  }\n  \n  #Legend expansion\n  if(legend.key.extend){\n    \n    map.out<-map.out+theme(legend.key.height = unit(0.5, \"in\"))\n    \n  }\n  \n  #Add facets, if specified\n  if (compare==TRUE){\n    map.out<-map.out+facet_wrap(~series)\n  }\n  \n  #Add map title, if specified\n  if (!is.null(map.title)){\n    map.out<-map.out+ggtitle(map.title)\n  }\n  \n  #   plot(map.out)\n  if(return.map){\n    \n    return(map.out)\n    \n  }else{\n    \n    print(map.out) \n    \n  }\n  \n}\n\n\ncompareMv<-function(inData,verbose=F,return.means=F){\n  \n  \"\n  \n  Computes the mean vector of variables of interest by cluster groups. \n  If specified, compares the mean vector of target variables to the overall \n  mean vector. \n\n  Arguments: \n\n    inData: data frame of cluster membership. First two columns must represent a \n      geographic identifier and cluster membership. \n\n    \n    verbose: optional. If TRUE, print the overall mean vector of variables of interest\n      to the console. \n\n  Returns: \n\n    If 'return.means=TRUE', returns the mean vectors of variable interest only.\n\n    Otherwise, default return is a matrix containing the percentage difference in \n    the mean vector of the variables of interest by group versus the overall mean. \n\n  \"\n  \n  inData<-aggregate(x=inData[,3:length(inData)],by=list(inData[,2]),na.rm=T,FUN=mean)\n  all.mean<-colMeans(inData[,2:ncol(inData)])\n  \n  if (verbose){\n    cat(sep='\\n\\n')\n    cat(paste(\"Variable Averages:\",toString(names(all.mean))),all.mean,sep=\"\\n\")\n  }\n  \n  if(return.means){ \n    \n    return(all.mean) \n    \n  }else{\n    \n    for (i in 2:ncol(inData)){inData[,i]<-round(100*(inData[,i]-all.mean[i-1])/all.mean[i-1])}\n    \n    return(inData)\n    \n  }  \n  \n}\n\nplotHeat <- function(inData,transpose=FALSE,flip=FALSE,compare=FALSE,series.list=NULL,return.heatMap=F){\n  \n  \"\n  Plots average profile characteristics of variables of interest by cluster groups\n  in a 'heatmap' style raster plot. If specified, compares multiple cluster solutions or\n  domains of variables of interest.\n  \n  Arguments: \n  \n    inData: data frame of cluster membership. First two columns must represent a \n      geographic identifier and cluster membership. \n    \n    transpose: optional. If TRUE, transpose the heatmap (X: cluster categories, Y: variables).\n    \n    flip: optional. If TRUE, reverse cardinality of values.\n    \n    compare: optional. If TRUE, plots multiple heatmaps using 'series.list'.\n    \n    series.list: optional. Used to define heatmap groups when 'compare=TRUE'.\n    \n    return.heatMap: optional. If TRUE, returns the heatmap ggplot object.\n  \n  Returns: \n  \n    The ggplot map object, when 'return.heatMap=TRUE'. Default behavior is to return a\n    plot in the R graphics device.\n  \n  \n  \"\n  \n  econz<-inData\n  \n  econz<-compareMv(econz)\n  \n  econz$Group.1<-as.factor(econz$Group.1)\n  econM=melt(econz)\n  \n  ##Flip value cardinality if specified\n  #This is useful i.e. when profiling dissimilarity and similar values low/dissimilar values high\n  if (flip){\n    \n    econM$value=-econM$value\n    \n  }\n  \n  if (compare){\n    \n    series<-c()\n    for (v in unique(econM$variable)){\n      \n      vv<-series.list[series.list$variable==v,]$series\n      series<-c(series,rep(vv,nrow(econM[econM$variable==v,])))\n      \n    }\n    \n    econM$series<-series\n    \n  }\n  \n  if (!transpose){\n    \n    heatMap<-ggplot(econM,aes(variable,Group.1,fill=value))+\n      geom_raster()+\n      scale_fill_gradient2(high='#e66101',mid='#f7f7f7',low='#5e3c99',guide=\"colourbar\",na.value='gray90')+\n      geom_text(aes(label=value, size=4),size=5,fontface='bold')+\n      theme(axis.text.x = element_text(angle=45, hjust=1))+\n      #       xlab(\"Attribute\")+\n      #       ylab(\"Class\")+\n      theme(axis.title.x=element_blank(),axis.title.y=element_blank())+\n      theme(legend.position=\"none\")\n    \n    if(compare){\n      \n      heatMap<-heatMap+facet_grid(~series,scales=\"free\",as.table=T)\n      \n    }\n    \n    plot(heatMap)\n    \n  }else{ #flip the values\n    \n    heatMap<-ggplot(econM,aes(Group.1,variable,fill=value))+\n      geom_raster()+\n      scale_fill_gradient2(high='#e66101',mid='#f7f7f7',low='#5e3c99',guide=\"colourbar\",na.value='gray90')+\n      geom_text(aes(label=value, size=4),size=5,fontface='bold')+\n      theme(axis.text.x = element_text(angle=45, hjust=1))+\n      #       xlab(\"Attribute\")+\n      #       ylab(\"Class\")+\n      theme(axis.title.x=element_blank(),axis.title.y=element_blank())+\n      theme(legend.position=\"none\")\n    \n    plot(heatMap)\n    \n  }\n  \n  if(return.heatMap){return(heatMap$data[,2:3])}\n}",
    "created" : 1455475499512.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1983657108",
    "id" : "9681308C",
    "lastKnownWriteTime" : 1455580159,
    "path" : "~/GitHub/suffolk_USGS/support_functions.R",
    "project_path" : "support_functions.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 3,
    "source_on_save" : true,
    "type" : "r_source"
}